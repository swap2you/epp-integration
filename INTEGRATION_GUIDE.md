# RUC Payment Integration Guide

## Overview
This guide provides step-by-step instructions for integrating the **Road User Charge (RUC)** payment functionality into any Spring Boot application. This is a generic, reusable component designed for Pennsylvania's RUC EPP (Electronic Payment Platform) integration.

---

## What This Component Does
- **Initiates payments** with Pennsylvania's EPP Commerce Hub
- **Processes payment callbacks** from EPP with transaction status
- **Persists transaction data** for auditing and reconciliation
- **Supports multiple integration patterns** (direct response, templates, ModelAndView)

---

## Prerequisites
- **Java 17+**
- **Spring Boot 3.x**
- **Spring Data JPA**
- **Oracle Database** (production) or **H2** (testing)
- **Pennsylvania EPP Account** with Application Code

---

## Integration Steps

### Step 1: Copy Core Files

#### 1.1 Configuration
Copy to your `config` package:
- `RucProperties.java` - Payment configuration properties
```java
@ConfigurationProperties(prefix = "ruc.payments")
public class RucProperties {
    private String provider;
    private String applicationCode;
    private String paymentGatewayUrl;
    private String returnUrl;
    // ... getters/setters
}
```

#### 1.2 Service Layer
Copy to your `service` package:
- `PaymentService.java` - Service interface
- `PaymentServiceImpl.java` - Business logic implementation
- `RucClient.java` - EPP integration client
- `TransactionService.java` - Transaction management interface
- `TransactionServiceImpl.java` - Transaction persistence logic

#### 1.3 Data Layer
Copy to your `entity` package:
- `RucTransaction.java` - JPA entity for transaction persistence

Copy to your `repo` package:
- `RucTransactionRepository.java` - Spring Data JPA repository

#### 1.4 DTOs
Copy to your `dto` package:
- `SaleDetails.java` - Payment request DTO
- `SaleItem.java` - Line item DTO
- `RucResponse.java` - EPP callback response DTO
- `ApplicationResponse.java` - Your application's response DTO

#### 1.5 Controllers (Optional - for testing)
Copy to your `controller` package:
- `PaymentController.java` - REST API endpoints
- `TestUIController.java` - Test form UI (development only)

#### 1.6 Utilities
Copy to your `util` package:
- `ModelMapper.java` - DTO mapping utility

#### 1.7 Exception Handling
Copy to your `exception` package:
- `PaymentProcessingException.java` - Custom exception class

---

### Step 2: Database Setup

#### 2.1 Add Flyway Migration
Create in `src/main/resources/db/migration/`:

**V1__ruc_transactions.sql** (Oracle):
```sql
CREATE TABLE ruc_transactions (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_key VARCHAR2(100) NOT NULL,
    application_unique_id VARCHAR2(100),
    application_code VARCHAR2(50),
    status VARCHAR2(20),
    raw_request CLOB,
    raw_response CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_ruc_tx_order_key ON ruc_transactions(order_key);
CREATE INDEX idx_ruc_tx_app_uid ON ruc_transactions(application_unique_id);
```

**For H2 Testing** (create in `db/migration/h2/`):
```sql
CREATE TABLE ruc_transactions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_key VARCHAR(100) NOT NULL,
    application_unique_id VARCHAR(100),
    application_code VARCHAR(50),
    status VARCHAR(20),
    raw_request TEXT,
    raw_response TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

### Step 3: Application Configuration

#### 3.1 Update application.yml
Add RUC payment configuration:

```yaml
ruc:
  payments:
    provider: ruc
    # Get Application Code from Pennsylvania EPP team
    applicationCode: ${RUC_APPLICATION_CODE:your-uuid-here}
    
    # Pennsylvania EPP URLs
    paymentGatewayUrl: ${RUC_PAYMENT_URL:https://epp.beta.pa.gov/Payment/Create}
    paymentGatewayAPI: ${RUC_API_URL:https://epp.API.beta.pa.gov}
    
    # Your application's callback URL
    returnUrl: ${RUC_RETURN_URL:https://your-domain.com/payments/ruc/result}
    
    # Environment: DEV, UAT, or PROD
    environment: ${RUC_ENV:UAT}
    
    # Merchant ID provided by EPP
    merchantId: ${RUC_MERCHANT_ID:your-merchant-id}
    
    # Security settings
    hashAlgorithm: ${RUC_HASH_ALGORITHM:SHA512}
    encryptionEnabled: ${RUC_ENCRYPTION:false}
```

#### 3.2 Update pom.xml
Ensure these dependencies exist:
```xml
<!-- Spring Boot Starter Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Boot Starter Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Spring Boot Starter Validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

<!-- Flyway for Database Migrations -->
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>

<!-- Oracle Driver (Production) -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc11</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- H2 Database (Testing) -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>test</scope>
</dependency>
```

---

### Step 4: Enable Configuration Properties

Add to your main application class or a configuration class:

```java
@Configuration
@EnableConfigurationProperties(RucProperties.class)
public class RucConfig {
    // Configuration enabled
}
```

---

### Step 5: Choose Your Integration Method

The RUC Payment component now supports **5 distinct integration patterns**. Choose the one that best fits your application architecture:

#### Method 1: Direct Response (Traditional)
**Best For**: .NET-style integration, legacy systems

```java
@PostMapping("/payment/initiate")
public void initiatePayment(@RequestParam Map<String, String> params, 
                           HttpServletResponse response) throws IOException {
    // Build payment details
    SaleDetails saleDetails = buildSaleDetails(params);
    
    // Generate EPP form HTML
    String formHtml = paymentService.buildEppForm(saleDetails);
    
    // Write directly to response
    response.setContentType("text/html");
    response.getWriter().write(formHtml);
}
```

#### Method 2: Template Engine (Spring Boot)
**Best For**: Spring Boot applications with Thymeleaf

```java
@PostMapping("/payment/initiate")
public String initiatePayment(@RequestParam Map<String, String> params, 
                             Model model) {
    // Build payment details
    SaleDetails saleDetails = buildSaleDetails(params);
    
    // Generate EPP form HTML
    String formHtml = paymentService.buildEppForm(saleDetails);
    
    // Add to model for template
    model.addAttribute("launchFormString", formHtml);
    model.addAttribute("gatewayUrl", eppProperties.getGatewayUrl());
    
    // Return template name
    return "epp-redirect";
}
```

**epp-redirect.html**:
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head><title>Redirecting to Payment Gateway</title></head>
<body>
    <div th:utext="${launchFormString}"></div>
</body>
</html>
```

#### Method 3: ModelAndView (Classic MVC)
**Best For**: Traditional Spring MVC applications

```java
@PostMapping("/payment/initiate")
public ModelAndView initiatePayment(@RequestParam Map<String, String> params) {
    // Build payment details
    SaleDetails saleDetails = buildSaleDetails(params);
    
    // Generate EPP form HTML
    String formHtml = paymentService.buildEppForm(saleDetails);
    
    // Create ModelAndView
    ModelAndView mav = new ModelAndView("RucInvoke");
    mav.addObject("launchFormString", formHtml);
    mav.addObject("gatewayUrl", eppProperties.getGatewayUrl());
    mav.addObject("orderKey", saleDetails.getOrderKey());
    
    return mav;
}
```

#### Method 4: AJAX/JSON Response (Modern SPA) ðŸ†•
**Best For**: React, Angular, Vue.js, Single Page Applications

```java
@PostMapping("/payment/initiate")
@ResponseBody
public Map<String, Object> initiatePayment(@RequestParam Map<String, String> params) {
    // Build payment details
    SaleDetails saleDetails = buildSaleDetails(params);
    
    // Generate EPP form HTML
    String formHtml = paymentService.buildEppForm(saleDetails);
    
    // Return JSON response
    Map<String, Object> response = new HashMap<>();
    response.put("success", true);
    response.put("orderKey", saleDetails.getOrderKey());
    response.put("gatewayUrl", eppProperties.getGatewayUrl());
    response.put("formHtml", formHtml);
    response.put("message", "Payment form generated successfully");
    
    return response;
}
```

**Frontend JavaScript**:
```javascript
// Make AJAX call
fetch('/payment/initiate', {
    method: 'POST',
    body: formData
})
.then(response => response.json())
.then(data => {
    if (data.success) {
        // Inject form HTML and auto-submit
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = data.formHtml;
        document.body.appendChild(tempDiv);
        // Form auto-submits via embedded script
    }
});
```

#### Method 5: Pure REST API (Microservices) ðŸ†•
**Best For**: Microservices, mobile apps, API integrations

```java
@PostMapping("/payment/initiate")
@ResponseBody
public Map<String, Object> initiatePayment(@RequestParam Map<String, String> params) {
    // Build payment details
    SaleDetails saleDetails = buildSaleDetails(params);
    
    // Convert to JSON string
    String jsonPayload = objectMapper.writeValueAsString(saleDetails);
    
    // Return structured JSON (no HTML)
    Map<String, Object> response = new HashMap<>();
    response.put("success", true);
    response.put("orderKey", saleDetails.getOrderKey());
    response.put("applicationCode", saleDetails.getApplicationCode());
    response.put("amount", saleDetails.getTotalAmount());
    response.put("gatewayUrl", eppProperties.getGatewayUrl());
    response.put("paymentData", jsonPayload);
    response.put("timestamp", LocalDateTime.now());
    response.put("instructions", "Submit paymentData to gatewayUrl as 'saleDetail' parameter");
    
    return response;
}
```

**Frontend JavaScript**:
```javascript
// Make AJAX call
fetch('/payment/initiate', {
    method: 'POST',
    body: formData
})
.then(response => response.json())
.then(data => {
    if (data.success) {
        // Build form manually
        const form = document.createElement('form');
        form.action = data.gatewayUrl;
        form.method = 'POST';
        
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'saleDetail';
        input.value = data.paymentData;
        
        form.appendChild(input);
        document.body.appendChild(form);
        form.submit();
    }
});
```

**Method Comparison**:

| Method | Response Type | Frontend Complexity | Best Use Case |
|--------|---------------|---------------------|---------------|
| 1. Direct Response | HTML | Low | Legacy systems, .NET-style |
| 2. Template | HTML | Low | Spring Boot + Thymeleaf |
| 3. ModelAndView | HTML | Low | Classic Spring MVC |
| 4. AJAX | JSON + HTML | Medium | SPAs, modern JavaScript |
| 5. REST API | JSON | High | Microservices, mobile apps |

---

### Step 6: Usage in Your Application

#### 5.1 Inject PaymentService
```java
@RestController
@RequestMapping("/api/payments")
public class YourPaymentController {
    
    private final PaymentService paymentService;
    
    public YourPaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    @PostMapping("/initiate")
    public ResponseEntity<String> initiatePayment(@RequestBody SaleDetails saleDetails) {
        String htmlForm = paymentService.initiatePayment(saleDetails);
        return ResponseEntity.ok(htmlForm);
    }
    
    @PostMapping("/callback")
    public ResponseEntity<ApplicationResponse> handleCallback(@RequestBody RucResponse rucResponse) {
        ApplicationResponse response = paymentService.processCallback(rucResponse);
        return ResponseEntity.ok(response);
    }
}
```

#### 5.2 Create SaleDetails
```java
SaleDetails saleDetails = new SaleDetails();
saleDetails.setOrderKey("ORDER-" + UUID.randomUUID());
saleDetails.setApplicationCode("your-epp-application-code");
saleDetails.setFirstName("John");
saleDetails.setLastName("Doe");
saleDetails.setAddress1("123 Main St");
saleDetails.setCity("Harrisburg");
saleDetails.setStateCode("PA");
saleDetails.setZipCode("17101");
saleDetails.setEmail("john.doe@example.com");

SaleItem item = new SaleItem();
item.setAmount(new BigDecimal("50.00"));
item.setDescription("Road User Charge Fee");
saleDetails.setItems(Collections.singletonList(item));
```

---

### Step 6: Environment Variables

Set these in your deployment environment:

```bash
# Required
export RUC_APPLICATION_CODE="your-uuid-from-epp-team"
export RUC_RETURN_URL="https://your-domain.com/payments/ruc/result"
export RUC_MERCHANT_ID="your-merchant-id"

# Optional (defaults provided)
export RUC_PAYMENT_URL="https://epp.pa.gov/Payment/Create"
export RUC_API_URL="https://epp.API.pa.gov"
export RUC_ENV="PROD"
```

---

### Step 7: Testing

#### 7.1 Test with H2 Database
Add to `application-test.yml`:
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
  flyway:
    locations: classpath:db/migration/h2
```

#### 7.2 Run Tests
```bash
mvn test
```

#### 7.3 Test UI (Optional)
If you copied `TestUIController`, access:
```
http://localhost:8080/test/form
```

---

## Integration Patterns

### Pattern 1: Direct HTML Response (.NET Style)
Best for: Direct browser submission
```java
@PostMapping("/pay")
public void initiatePayment(@RequestBody SaleDetails details, HttpServletResponse response) {
    String html = paymentService.initiatePayment(details);
    response.setContentType("text/html; charset=UTF-8");
    response.getWriter().write(html);
}
```

### Pattern 2: Template Rendering (Spring Style)
Best for: Server-side rendering
```java
@PostMapping("/pay")
public String initiatePayment(@RequestBody SaleDetails details, Model model) {
    String htmlForm = paymentService.initiatePayment(details);
    model.addAttribute("rucForm", htmlForm);
    return "ruc-redirect"; // Thymeleaf template
}
```

### Pattern 3: REST API (Modern SPA)
Best for: React, Angular, Vue.js apps
```java
@PostMapping("/pay")
public ResponseEntity<String> initiatePayment(@RequestBody SaleDetails details) {
    String htmlForm = paymentService.initiatePayment(details);
    return ResponseEntity.ok(htmlForm);
}
```

---

## Callback Handling

EPP will POST to your `returnUrl` with these fields:
- `orderKey` - Your unique order identifier
- `status` - Payment status: "COM" (complete), "CAN" (cancelled), "DEC" (declined)
- Additional EPP response fields

Your callback endpoint:
```java
@PostMapping("/payments/ruc/result")
public ApplicationResponse handleCallback(@RequestBody RucResponse response) {
    return paymentService.processCallback(response);
}
```

---

## Status Codes

| Status | Meaning | Action |
|--------|---------|--------|
| COM | Completed | Payment successful - fulfill order |
| CAN | Cancelled | User cancelled - log and notify |
| DEC | Declined | Payment declined - retry or alternative payment |

---

## Security Considerations

1. **HTTPS Only**: All production URLs must use HTTPS
2. **Validate Callbacks**: Always verify `orderKey` exists in your system
3. **Idempotency**: Use unique `orderKey` per transaction
4. **Environment Variables**: Never hardcode credentials
5. **Transaction Logging**: All requests/responses are logged in `ruc_transactions`

---

## Troubleshooting

### Issue: "RUC integration is not enabled"
**Solution**: Ensure `ruc.payments.provider=ruc` in application.yml

### Issue: "Application Code is required"
**Solution**: Set `RUC_APPLICATION_CODE` environment variable

### Issue: Database migration fails
**Solution**: Check Flyway is enabled and migration scripts are in correct location

### Issue: EPP returns error
**Solution**: Check EPP logs, verify `applicationCode`, `merchantId`, and return URL

---

## Production Checklist

- [ ] Environment variables configured
- [ ] Database migrations tested
- [ ] Return URL accessible from EPP servers
- [ ] HTTPS enabled on return URL
- [ ] Merchant ID and Application Code validated with EPP team
- [ ] Transaction logging verified
- [ ] Error handling tested (declined, cancelled scenarios)
- [ ] Load testing completed

---

## Support

For EPP-specific issues, contact Pennsylvania EPP Support:
- **UAT Environment**: Use beta URLs
- **Production**: Use production EPP URLs
- **Documentation**: Refer to Pennsylvania EPP Commerce Hub documentation

For integration issues with this component:
- Review transaction logs in `ruc_transactions` table
- Check application logs for `PaymentService` and `RucClient` entries
- Verify configuration in `application.yml`

---

## Summary

This RUC payment component is:
- âœ… **Generic**: Works with any Spring Boot application
- âœ… **Modular**: Clean separation of concerns
- âœ… **Reusable**: Copy and integrate into multiple projects
- âœ… **Simple**: Minimal configuration required
- âœ… **Production-Ready**: Includes transaction persistence and error handling

**Next Steps**: Follow Steps 1-7 above to integrate into your application.
